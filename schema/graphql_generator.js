var fs = require('fs'),
    lingo = require('lingo'),
    _ = require('lodash'),
    inputCustomMutations = fs.readFileSync('./schema/mutations.js', 'utf-8'),
    GraphqlGenerator = function () {},
    h = require('./helper.js'),
    query = require('./queries.js').Query,
    mutation = require('./mutations.js').Mutation;

import {
  GraphQLObjectType,
  GraphQLInputObjectType,
  GraphQLString,
  GraphQLInt,
  GraphQLSchema,
  GraphQLList,
  GraphQLNonNull
} from 'graphql';

GraphqlGenerator.prototype.printMetadata = function(dbMetadata) {
  writeGraphQLSuperModels(dbMetadata);
  writeModelFiles(dbMetadata);
  writeTypesFile(dbMetadata);
  writeMutationsFile(dbMetadata);
  writeQueriesFile(dbMetadata);
  writeSchemaDefinition(dbMetadata);
  // process.exit()
}

// Starts here for model file generation

var writeModelFiles = function(dbMetadata) {
  for (var property in dbMetadata.tables) {
    var singularLowercaseTableName = lingo.en.singularize(property).toLowerCase();
    var singularCapitalizedTableName = lingo.capitalize(h.toCamelCase(singularLowercaseTableName))

    var data = `import { Base${singularCapitalizedTableName} } from '../../generated/models'
var knex = require('../../database/connection');\n
export class ${singularCapitalizedTableName} extends Base${singularCapitalizedTableName} {\n\n}`;

    var pathName = `./schema/models/${singularLowercaseTableName}.js`
    if (fs.existsSync(pathName)) {
      console.log('Model file already exists and will not be overwritten.')
    } else {
      fs.writeFileSync(pathName, data, { flag: 'wx' }, function (err) {
        if (err) {
          console.log('file already exists.')
        } else {
          console.log('created file.')
        }
      });
    }
  }
}

// Ends model file generation

// Starts here for super model generation

var writeGraphQLSuperModels = function(dbMetadata) {
  var data = `// This file is generated by Allograph. We recommend that you do not modify this file.
var knex = require('../database/connection');`

  for (var property in dbMetadata.tables) {
    if (dbMetadata.tables.hasOwnProperty(property)) {
      data += modelData(dbMetadata.tables[property]);
    }
  }

  fs.writeFileSync('./generated/models.js', data, 'utf-8');
}

var modelData = function(tableInfo) {
  var tableName = tableInfo.name,
      pluralTableName = lingo.en.pluralize(h.toCamelCase(tableName)),
      singularTableName = lingo.en.singularize(h.toCamelCase(tableName)),
      singularCapitalizedTableName = lingo.capitalize(singularTableName),
      validArgs = toArgs(tableInfo.fields);

  var data = `\n\nexport class Base${singularCapitalizedTableName} {
  ${pluralTableName}(args) {
    return knex('${tableName}').where(args);
  }

  create${singularCapitalizedTableName}(args) {
    return knex.returning('id').insert({`

  data += validArgs

  data += `\n    }).into('${tableName}').then(id => {
      return knex('${tableName}').where({ id: id[0] }).first();
    });
  }

  update${singularCapitalizedTableName}(args) {
    return knex('${tableName}').where({ id: args.id }).returning('id').update({`

  data += validArgs

  data += `\n    }).then(id => {
      return knex('${tableName}').where({ id: id[0] }).first();
    });
  }

  delete${singularCapitalizedTableName}(args) {
    return knex('${tableName}').where({ id: args.id }).del()
  }
}`

return data;
}

var toArgs = function(fields) {
  var args = '';
  for (var field in fields) {
    var type = fields[field].data_type;

    if (field != 'id') {
      if (validArgsType(type)) {
        args += `\n      ${field}: args.${field},`;
      }
    }
  }

  return args;
}

var validArgsType = function(type) {
  var typeMap = {
          'character varying': 'String',
          'integer': 'Int',
          'text': 'String',
          'boolean': 'Boolean',
          'timestamp with time zone': 'String'
        };

  return typeMap[type]
}

// Super Model generation ends

// Translating to GraphQL Type starts here
var graphQLData = function() {
  return `import {
  GraphQLObjectType,
  GraphQLString,
  GraphQLInt,
  GraphQLSchema,
  GraphQLList,
  GraphQLBoolean,
  GraphQLNonNull
} from 'graphql';

var knex = require('../database/connection'),
    jwt = require('jsonwebtoken');`
}

var objectDescription = function(tableName, description) {
  return `\n
const ` + tableName + ` = new GraphQLObjectType({
  name: '` + tableName + `',
  description: '` + description + `',
  fields: () => {
    return {`
}

var singularCapitalizedTableName = function(name) {
  var singularName = lingo.en.singularize(name)
  return lingo.capitalize(singularName);
}

var foreignKeyColumnData = function(column, tableName, pk_column, fk_column, psqlType) {
  var listType = psqlType.match(/\[(\w+)\]/),
      args,
      returnValue = `;`,
      fieldName = column;

  if (listType) {
    args = `{ ${fk_column}: ${tableName}.${pk_column} }`
  } else {
    args = `{ ${pk_column}: ${tableName}.${fk_column} }`
    returnValue = `.first();`
    fieldName = lingo.en.singularize(h.toCamelCase(column));
  }

  return '\n      ' + fieldName + `: {
        type: ` + psqlTypeToGraphQLType(psqlType) + `,
        resolve (` + tableName + `, args, context) {
          return knex('${column}').where(` + args + `)` + returnValue + `
        }
      },`
}

var columnData = function(column, table, psqlType, is_nullable) {
  var typeData = `\n        type: `
  if (!is_nullable) {
    typeData += `new GraphQLNonNull(` + psqlTypeToGraphQLType(psqlType) + `),`
  } else {
    typeData += psqlTypeToGraphQLType(psqlType) + `,`
  }

  return '\n      ' + h.toCamelCase(column) + `: {` + typeData +
`\n        resolve (` + lingo.en.singularize(table) + `, args, context) {
          return ` + lingo.en.singularize(table) + '.' + column + `;
        }
      },`
}

var closingBrackets = function() {
  return `
    };
  }
});`
}

var writeTypesFile = function(dbMetadata) {
  var data = graphQLData();
  for (var table in dbMetadata.tables) {

    if (dbMetadata.tables.hasOwnProperty(table)) {

      var objTypeName = singularCapitalizedTableName(h.toCamelCase(table));
      var description = dbMetadata.tables[table].description;
      data += objectDescription(objTypeName, description);

      for (var column in dbMetadata.tables[table].fields) {
        var psqlType = dbMetadata.tables[table].fields[column].data_type;
        var is_nullable = dbMetadata.tables[table].fields[column].is_nullable;

        if (dbMetadata.tables.hasOwnProperty(column)) {
          var fk_column = dbMetadata.tables[table].fields[column].fk_column
          var pk_column = dbMetadata.tables[table].fields[column].pk_column
          data += foreignKeyColumnData(column, objTypeName, pk_column, fk_column, psqlType);
        } else {
          data += columnData(column, table, psqlType, is_nullable);
        }
      }

      data += closingBrackets();
    };
  };

  data += '\n\n'

  addTypeDefinitionExportStatement(data, dbMetadata);

  var importStatements = typeImportStatements() + graphQLData() + "\n\n";

  fs.writeFileSync('./generated/schema.js', importStatements, 'utf-8');
}

var typeImportStatements = function() {
  return "import { Trainer, Pokemon } from './type_definitions'\n\n"
}

var addTypeDefinitionExportStatement = function(data, dbMetadata) {
  // var schema = fs.readFileSync('./generated/schema.js', 'utf-8')
  var exportStatement = `\n\nexport {`

  for (var tableName in dbMetadata.tables) {
    var singularLowercaseTableName = lingo.en.singularize(tableName);
    var singularCapitalizedTableName = lingo.capitalize(singularLowercaseTableName);
    exportStatement += ` ${singularCapitalizedTableName},`
  }

  exportStatement = exportStatement.slice(0, -1);
  data += exportStatement + " }"

  fs.writeFileSync('./generated/type_definitions.js', data, 'utf-8');
}

// Translating to GraphQL Type ends here

// Write Queries Begins

var writeQueriesFile = function(dbMetadata) {
  var newData = `const queryFields = {`

  var customQueries = query.fields();

  for (var customQuery in customQueries) {
    if (Object.keys(customQueries[customQuery]).length === 0) { continue; }
    newData += h.customFieldType(customQueries, customQuery)

    for (var arg in customQueries[customQuery].args) {
      newData += h.customArgsType(arg, customQueries[customQuery].args[arg].type)
    }

    newData += `\n        },\n        `
    newData += customQueries[customQuery].resolve.toString()
    newData += `\n      },`
  }

  for (var property in dbMetadata.tables) {
    var tableName = h.singularCapitalizedTableName(property)
    var pluralTableName = lingo.en.pluralize(lingo.en.singularize(property.toLowerCase())) // Account for both singular and plural table names.

    if (Object.keys(customQueries).includes(pluralTableName)) { continue; }

    newData += queryTableHeader(tableName)

    for (var column in dbMetadata.tables[property].fields) {
      var psqlType = dbMetadata.tables[property].fields[column].data_type;
      var typeMap = {
            'character varying': 'GraphQLString',
            'integer': 'GraphQLInt',
            'boolean': 'GraphQLBoolean',
            'text': 'GraphQLString',
            'timestamp with time zone': 'GraphQLString'
          };

      if (typeMap[psqlType]) {
        newData += queryTableArgs(column, psqlType);
      }
    }

    newData = newData.slice(0, -1);
    newData += queryResolveFunction(tableName)
  }

  newData += '\n    };\n\n'
  fs.writeFileSync('./generated/queries.js', newData, 'utf-8')
}

var queryTableArgs = function(column, psqlType) {
  return `\n          ${h.toCamelCase(column)}: {
            type: ` + psqlTypeToGraphQLType(psqlType) + `
          },`
}

var queryTableHeader = function(tableName) {
  var camelCasePluralTableName = lingo.en.pluralize(h.toCamelCase(tableName)),
      graphQLObjName = lingo.capitalize(h.toCamelCase(tableName));

  return `\n      ${camelCasePluralTableName}: {
        type: new GraphQLList(${graphQLObjName}),
        args: {`
}

var psqlTypeToGraphQLType = function(psqlType) {
  var listType = psqlType.match(/\[(\w+)\]/),
      timestamp = psqlType.match(/^timestamp/),
      typeMap = {
        'character varying': 'GraphQLString',
        'integer': 'GraphQLInt',
        'boolean': 'GraphQLBoolean',
        'text': 'GraphQLString',
        'timestamp with time zone': 'GraphQLString'
      }

  if (listType) {
    return 'new GraphQLList(' + lingo.capitalize(h.toCamelCase(listType[1])) + ')';
  } else if (typeMap[psqlType]) {
    return typeMap[psqlType];
  } else if (timestamp) {
    return 'GraphQLString';
  } else {
    return lingo.capitalize(lingo.en.singularize(h.toCamelCase(psqlType)));
  }
}

var queryResolveFunction = function(tableName) {
  var capitalizeTableName = lingo.capitalize(h.toCamelCase(tableName)),
      lowercaseTableName = h.toCamelCase(tableName),
      pluralizedLowercaseTableName = lingo.en.pluralize(lowercaseTableName);

  return `
        },
        resolve (root, args, context) {
          var ${lowercaseTableName} = new ${capitalizeTableName}Class()
          return ${lowercaseTableName}.${pluralizedLowercaseTableName}(args);
        }
      },`
}

// writeQueries ends here

// writeMutations starts here

var writeMutationsFile = function(dbMetadata) {
  var newData = `const mutationFields = {`
  var customMutations = mutation.fields();

  for (var customMutation in customMutations) {
    if (Object.keys(customMutations[customMutation]).length === 0) { continue; }

    newData += h.customFieldType(customMutations, customMutation)

    for (var arg in customMutations[customMutation].args) {
      newData += h.customArgsType(arg, customMutations[customMutation].args[arg].type)
    }

    newData += `\n        },\n        `
    newData += customMutations[customMutation].resolve.toString()
    newData += `\n      },`
  }

  // if there is table called 'users', add default login mutation
  if (Object.keys(dbMetadata.tables).includes("users") &&
    Object.keys(dbMetadata.tables["users"].fields).includes("email") &&
    Object.keys(dbMetadata.tables["users"].fields).includes("password")) {
    newData += mutationLogin(dbMetadata.tables["users"]);
  } else {
    console.log("You don't have a table 'users' with columns 'password' and 'email',")
    console.log("so there won't be an auto generated default login mutation.")
  }


  for (var property in dbMetadata.tables) {
    if (dbMetadata.tables.hasOwnProperty(property)) {
      var propertyCamelCase = h.toCamelCase(property);

      if (!Object.keys(customMutations).includes("add" + h.singularCapitalizedTableName(propertyCamelCase))) {
        newData += mutationAdd(propertyCamelCase, dbMetadata.tables[property]);
      }
      if (!Object.keys(customMutations).includes("update" + h.singularCapitalizedTableName(propertyCamelCase))) {
      newData += mutationUpdate(propertyCamelCase, dbMetadata.tables[property]);
      }
      if (!Object.keys(customMutations).includes("delete" + h.singularCapitalizedTableName(propertyCamelCase))) {
      newData += mutationDelete(propertyCamelCase, dbMetadata.tables[property]);
      }
    };
  };
  newData = newData.slice(0, -1);
  newData += '\n    };';
  fs.writeFileSync('./generated/mutations.js', newData, 'utf-8')
};

var mutationLogin = function(tableData) {
  var newData = `\n      login: {
        type: GraphQLString,
        args: {`;

  for (var column in tableData.fields) {
    var psqlType = tableData.fields[column].data_type;

    if (validLoginType(psqlType) && (column === 'email' || column === 'password')) {
      var graphQLType = psqlTypeToGraphQLType(psqlType);
      newData += `\n          ${column}: {
            type: new GraphQLNonNull(${graphQLType})
          },`;
    }
  }

  newData = newData.slice(0, -1);
  newData += `
        },
        resolve (root, args, context) {
          var user = new UserClass();
          return user.users(args).then(user => {
            return jwt.sign({ user: user[0] }, 'allograph-secret' );
          });
        }
      },`
  return newData
}

var validLoginType = function(psqlType) {
  var typeMap = {
        'character varying': 'GraphQLString',
        'integer': 'GraphQLInt',
        'text': 'GraphQLString'
      };
  return !!typeMap[psqlType];
}

var mutationAdd = function(pluralLowercaseTableName, tableData) {
  var singularLowercaseTableName = lingo.en.singularize(pluralLowercaseTableName);
  var singularCapitalizedTableName = lingo.capitalize(singularLowercaseTableName);

  var newData = `\n      add${singularCapitalizedTableName}: {
        type: ${singularCapitalizedTableName},
        args: {`;

  for (var column in tableData.fields) {
    var psqlType = tableData.fields[column].data_type;
    var pk_datatype = tableData.fields[column].pk_datatype;

    if (validForMutation(psqlType) && column !== 'id') {
      var graphQLType = psqlTypeToGraphQLType(psqlType);
      if (!tableData.fields[column].is_nullable) {
        newData += `\n          ${h.toCamelCase(column)}: {
            type: new GraphQLNonNull(${graphQLType})
          },`;
      } else {
        newData += `\n          ${h.toCamelCase(column)}: {
            type: ${graphQLType}
          },`;
      }
    } else if (pk_datatype) {
      var pk_graphQLType = psqlTypeToGraphQLType(pk_datatype);
      var fk_column = h.toCamelCase(tableData.fields[column].fk_column);

      newData += `\n          ${fk_column}: {
            type: new GraphQLNonNull(${pk_graphQLType})
          },`;
    }
  }

  newData = newData.slice(0, -1);
  newData += `
        },
        resolve (root, args, context) {
          var ${singularLowercaseTableName} = new ${singularCapitalizedTableName}Class()
          return ${singularLowercaseTableName}.create${singularCapitalizedTableName}(args);
        }
      },`
  return newData
}

var mutationUpdate = function(pluralLowercaseTableName, tableData) {
  var singularLowercaseTableName = lingo.en.singularize(pluralLowercaseTableName);
  var singularCapitalizedTableName = lingo.capitalize(singularLowercaseTableName);

  var newData = `\n      update${singularCapitalizedTableName}: {
        type: ${singularCapitalizedTableName},
        args: {`;

  for (var column in tableData.fields) {
    var psqlType = tableData.fields[column].data_type;
    if (validForMutation(psqlType)) {
      var graphQLType = psqlTypeToGraphQLType(psqlType);
      if (!tableData.fields[column].is_nullable) {
        newData += `\n          ${h.toCamelCase(column)}: {
            type: new GraphQLNonNull(${graphQLType})
          },`;
      } else {
        newData += `\n          ${h.toCamelCase(column)}: {
            type: ${graphQLType}
          },`;
      }
    }
  }
  newData = newData.slice(0, -1);
  newData += `\n        },
        resolve (root, args, context) {
          var ${singularLowercaseTableName} = new ${singularCapitalizedTableName}Class()
          return ${singularLowercaseTableName}.update${singularCapitalizedTableName}(args);
        }
      },`

  return newData
}

var mutationDelete = function(pluralLowercaseTableName, tableData) {
  var singularLowercaseTableName = lingo.en.singularize(pluralLowercaseTableName);
  var singularCapitalizedTableName = lingo.capitalize(singularLowercaseTableName);

  var newData = `\n      delete${singularCapitalizedTableName}: {
        type: ${singularCapitalizedTableName},
        args: {`;

  for (var column in tableData.fields) {
    var psqlType = tableData.fields[column].data_type;
    if (validForMutation(psqlType) && column === 'id') {
      var graphQLType = psqlTypeToGraphQLType(psqlType);
      if (!tableData.fields[column].is_nullable) {
        newData += `\n          ${h.toCamelCase(column)}: {
            type: new GraphQLNonNull(${graphQLType})
          },`;
      } else {
        newData += `\n          ${h.toCamelCase(column)}: {
            type: ${graphQLType}
          },`;
      }
    } else {
      return '';
    }
  }
  newData = newData.slice(0, -1);
  newData += `\n        },
        resolve (root, args, context) {
          var ${singularLowercaseTableName} = new ${singularCapitalizedTableName}Class()
          return ${singularLowercaseTableName}.delete${singularCapitalizedTableName}(args);
        }
      },`

  return newData
}

var validForMutation = function(psqlType) {
  var typeMap = {
        'character varying': 'GraphQLString',
        'integer': 'GraphQLInt',
        'boolean': 'GraphQLBoolean',
        'text': 'GraphQLString',
        'timestamp with time zone': 'GraphQLString'
      };
  return !!typeMap[psqlType];
}

// writeMutations ends here

var importModels = function(dbMetadata) {
  var importStatement = '// This file is generated by Allograph. We recommend that you do not modify its contents.\n\n'

  for (var tableName in dbMetadata.tables) {
    var singularLowercaseTableName = lingo.en.singularize(tableName);
    var singularCapitalizedTableName = lingo.capitalize(h.toCamelCase(singularLowercaseTableName))
    importStatement += `import { ${singularCapitalizedTableName} as ${singularCapitalizedTableName}Class } from '../schema/models/${singularLowercaseTableName}'\n`
  }

  return importStatement
}

var writeSchemaDefinition = function(dbMetadata) {
  var schema = importModels(dbMetadata);
  // Type definitions already written to schema file b/c needed to add export
  // statement to type definition file before generating queries & mutations
  schema += fs.readFileSync('./generated/schema.js', 'utf-8');
  schema += fs.readFileSync('./generated/queries.js', 'utf-8');
  schema += fs.readFileSync('./generated/mutations.js', 'utf-8');

  schema += '\n\n' + `module.exports = {
  queryFields,
  mutationFields
};`

  fs.writeFileSync('./generated/schema.js', schema, 'utf-8');
}

exports.GraphqlGenerator = new GraphqlGenerator();